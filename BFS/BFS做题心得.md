# BFS算法做题心得

为何深度优先搜索，和递归，更适合做回溯算法，而bfs不适合用在回溯算法里呢？

回溯算法的核心是 “尝试 - 失败 - 回退 - 再尝试” 的过程，需要在搜索过程中不断探索路径、记录中间状态，并在发现路径不可行时**撤销上一步操作**（即 “回溯”），回到之前的状态继续尝试其他可能性。这种特性与深度优先搜索（DFS）和递归的工作方式高度契合，而广度优先搜索（BFS）由于其自身特性，在回溯场景中存在明显局限。具体原因如下：

### 1. **DFS / 递归与回溯的天然适配性**

#### （1）路径探索的连续性与状态可回溯性

DFS 的核心是 “一条路走到黑”：从起点出发，沿着一条路径不断深入，直到无法继续（遇到目标或死胡同），再回溯到上一个岔路口尝试其他路径。

递归本身的调用栈天然记录了路径的 “历史状态”：每一层递归对应路径中的一个步骤，递归调用栈保存了当前路径的所有中间状态（如已选择的元素、访问过的节点等）。当某条路径不可行时，只需从当前递归层返回（即 “回溯”），就能自动恢复到上一层的状态，继续探索其他分支。

例如，在 “全排列” 问题中，递归调用栈会记录 “已选择的元素”，当尝试完一个元素的所有排列后，退回到上一层并移除该元素（撤销选择），即可尝试下一个元素，这正是回溯的核心操作。

#### （2）空间效率：只保存当前路径的状态

DFS 在探索过程中，只需维护**当前正在探索的路径**的状态（通过递归栈或手动栈），无需保存所有可能的路径。当回溯时，只需释放当前路径的最后一步状态，空间复杂度通常为 O (递归深度)，对于多数问题（如树的深度、组合的长度）是可控的。

### 2. **BFS 不适合回溯的核心原因**

BFS 的核心是 “逐层扩散”：从起点出发，先探索所有距离为 1 的节点，再探索所有距离为 2 的节点，以此类推。它的特点是**同时维护多条路径的状态**，且一旦进入下一层，就不会再回到上一层。这种特性与回溯算法的需求存在根本冲突：

#### （1）状态无法 “回退”

BFS 中，每一层的状态是 “当前层所有可能路径的集合”，这些状态是 “向前推进” 的，无法像 DFS 那样 “撤销上一步操作”。例如，在 “全排列” 问题中，BFS 会同时记录 “以 1 开头”“以 2 开头”“以 3 开头” 等所有初始状态，当探索到某一层发现路径不可行时，无法简单地 “删除最后一个元素” 回到上一层，因为上一层的状态已经被 “覆盖” 或需要额外空间保存。

#### （2）空间复杂度极高

BFS 需要保存**所有当前层的状态**（例如，第 k 层有 n 个状态，就需要保存 n 个完整的路径信息）。对于回溯问题（如组合、子集、排列），状态数量会随层数呈指数级增长，导致空间复杂度急剧上升（远高于 DFS 的线性空间）。

#### （3）不符合回溯的 “尝试 - 回退” 逻辑

回溯的本质是 “试错”，需要在一条路径上反复试错并调整；而 BFS 更适合 “寻找最短路径” 等无需回退的场景，其设计目标是 “快速找到到达目标的最短距离”，而非 “探索所有可能路径并回退调整”。

### 总结

回溯算法的核心是 “路径探索 + 状态回退”，而：

- DFS（尤其是递归实现的 DFS）通过 “深度优先” 的探索方式和 “递归栈保存状态” 的特性，完美匹配回溯的需求，且空间效率高；
- BFS 因 “逐层扩散”“无法回退状态”“空间复杂度高” 等特点，与回溯的核心逻辑冲突，因此很少用于回溯算法。

不过，BFS 并非完全不能实现类似回溯的功能（例如通过手动保存所有路径状态），但相比 DFS 会显得冗余且低效，因此实际中几乎不会这样使用。

### 20251115

所以，BFS算法看起来和DFS很相似，但其实题型的差异性很明显，需要单独另列题型

### 20251115

宽度优先遍历基本内容

bfs的特点，是逐层扩散，从源头点道目标点扩散了几层，最短路径就是多少

bfs可以使用的特征是，任意两个节点之间的互相距离相同，（无向图）

bfs开始时，可以是单个源头，也可以是多个源头

bfs频繁使用队列，形式可以是，单点弹出，或整层弹出

bfs进行时，进入队列的点需要标记状态，防止同一个节点重复进入队列

bfs进行时，可能会包含剪枝策略的设计



bfs是个理解难度很低的算法，难点在于节点如何找到路，路的展开和剪枝设计



### 常见题型：

单源，多源宽度优先遍历基本过程

01BFS，宽度优先遍历与双端队列结合

宽度优先遍历与优先级队列（堆）结合

宽度优先遍历与深度优先遍历结合，去生成路径



### BFS算法需要用到的变量，

一个双端队列，用来将每次新扩展出来的元素加进来，并且按照先进先出的原则，遍历每个队列的元素

1个层数计数器，level，和两个每层节点数量的计数器。层数就是记录当前节点到源点的距离，逐层遍历，当一层的节点遍历完了，在遍历过程中，队列内当前层的节点数量逐渐减少，下一层的节点数量逐渐增加。当前层的节点计数器归0时，将level加一，开始遍历下一层的节点。

一个二维bool值，矩阵，用来记录，哪些点已经被访问过了，防止被重复访问。

但也存在一个问题，如果往两个方向扩展，其中一个点，已经被其中一条路径访问过了，那另一个路径能否再次访问该点呢？毕竟我们要防止的是，一个节点被同一个路径重复访问，而不是一个节点被不同路径各访问一次。问了豆包后，得到答案，为每条路径单独维护一个已访问队列。但每次添加新的节点时，一个路径就会增加很多的可选方向，进而导致，已访问集合，也会因可选方向的数量增多，而拷贝，消耗巨量的内存空间。这也是为什么，DFS加回溯效率更高 的原因，回溯算法，仅仅用一个栈，就能解决重复访问问题。

所以，因为这个防止重复访问的问题，导致的已访问路径的记录问题，使得使用全局矩阵来记录，会更简单，但这种记录方式，往往是最短路径问题，一个点被访问过了，其他路径也不再允许被访问了。但对于全排列问题，多路径问题，仍必须要用已访问集合来记录，所以这类问题比较困难，也很少考察。 

还有一个，四个移动方向的列表，往上下左右，各个方向移动的列表，用来访问一个节点时，往各个方向扩展，从而获取新节点 

所以，bfs的遍历，往往是，一层while循环，套两层for循环。最外层的while，主要保障双端队列不为空。第一层for循环，从队列中弹出当前层的节点。第二层for循环，向4个方向扩展，把新节点添加到队列里，并将当前节点设置为已访问状态。