回溯算法就是在dfs上加了一个撤销选择的操作，往往用来解决全排列问题，时间复杂度非常高，全排列复杂度为：n！*n^2,N皇后复杂度为：n^n*n^2,其中，前者为树上的节点个数，后者为递归函数的复杂度。递归的时间复杂度为递归节点个数*递归函数复杂度。
### 回朔关键点 通过分析发现，回朔法实现的三大技术关键点分别是：

一条路走到黑
回退一步
另寻他路
### 关键点的实现 那么如何才能用代码实现上述三个关键点呢？

for 循环
递归
#### 解释如下

for循环的作用在于另寻他路： 你可以用for循环可以实现一个路径选择器的功能，

该路径选择器可以逐个选择当前节点下的所有可能往下走下去的分支路径。 

例如： 现在你走到了节点a，a就像个十字路口，你从上面来到达了a，可以继续向下走。

若此时向下走的路有i条，那么你肯定要逐个的把这i条都试一遍才行。

而for的作用就是可以让你逐个把所有向下的i个路径既不重复，也不缺失的都试一遍

递归可以实现一条路走到黑和回退一步： 一条路走到黑： 递归意味着继续向着for给出的路径向下走一步。 

如果我们把递归放在for循环内部，那么for每一次的循环，都在给出一个路径之后，进入递归，也就继续向下走了。

直到递归出口（走无可走）为止。 那么这就是一条路走到黑的实现方法。 递归从递归出口出来之后，就会实现回退一步。

因此for循环和递归配合可以实现回朔： 当递归从递归出口出来之后。

上一层的for循环就会继续执行了。而for循环的继续执行就会给出当前节点下的下一条可行路径。

而后递归调用，就顺着这条从未走过的路径又向下走一步。这就是回朔

backtrack的公式：

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
for 选择 in 选择列表:
筛选掉不合法目标
        做选择，装进path里，
        backtrack(路径, 选择列表)
        撤销选择，path.pop_back()
```


		

0730，回溯算法有两个难点，分别为：backtrack的参数如何确定，第二个则是，筛选条件的设计，第三个是for循环的i是啥？
