# 二分查找解题感悟

二分法，本身是很简单的，先定义左右指针，然后while循环，左指针小于右指针，计算中间位置，将移动左指针或右指针到中间位置。

怎么说呢？是最开始的双指针法的进阶版，对向双指针每次循环的步进速度是1，而二分查找每次循环的步进速度是n/2，所以，整体时间速度是log2n

诚然，刚开始很简单，但往后做，就会发现，事情没那么简单，虽然解法很简单，但会通过问题，千方百计的迷惑你。让你看不出，到底要对啥进行二分。

二分查找的序列，必须是有序的，单调性，

## 难点和典型问题

### 旋转有序数组

虽然数组是有序的，但进行了一下旋转，需要先找到最低点，然后再将原数组分成两个子数组进行二分

### 有重复元素

尽管单调性可以满足，有些数组却引入了重复元素，所以在指针移动时，还要考虑去重

### 各种开闭区间的写法

包括，全闭区间，左闭右开，开区间，等等，要掌握清楚，因为有些问题适合某种特定区间的写法。不同区间的写法，在初始值，while循环里是<还是小于等于，指针移动时要不要在mid上再加1，返回值是返回left还是right

### 用一个数组进行演示

写好一个查找后，先用测试案例，自己脑8一遍，一步步的执行，看是否是你想要的结果，然后再根据反馈进行修改算法

### left和right的含义

需要理解，while循环结束时，left和right所表示的含义

这里有一个手撕的upped_bound，表示结束时，left是第一个，大于target的值

```python
def upper_bound(arr, target):
    left = 0
    right = len(arr) - 1  # 右边界初始化为数组最后一个元素的索引
    
    while left <= right:
        mid = left + (right - left) // 2  # 避免整数溢出（Python中无此问题，但保持习惯）
        
        if arr[mid] <= target:
            # 当前元素小于等于目标值，说明第一个大于target的位置在右侧
            left = mid + 1
        else:
            # 当前元素大于目标值，可能是候选位置，但需继续向左查找更左侧的符合条件位置
            right = mid - 1
    
    # 循环结束时，left即为第一个大于target的位置
    return left
```

