# **堆结构与堆排序**

### 堆结构

完全二叉树和前缀数组范围的对应

i 的父亲节点：（i-2）/2，i的左孩子：i * 2 + 1， i 的右孩子：i * 2 + 2

#### 堆的定义：

（大根堆、小根堆），本节课按照大根堆来讲解，小根堆同理。所谓的大根堆，表示了，对于每棵子树，其中的最大值一定在子树的根节点。

#### 堆的调整：

heapInsert  (向上调整)，heapify（向下调整）

heapInsert、 heapify方法的单次调用，时间复杂度O(logN), 这是完全二叉树的结构决定的



### 堆排序

1. 从顶到底建堆，时间复杂度O(n * log n), log1 + log2 + log3 + ...  + logn  -> O(n * log n).或者用倍增分析法：建堆的复杂度分析，+ 子矩阵数量的复杂度分析
2.  从底到顶建堆，时间复杂度O(n), 总代价就是简单的等比数列关系，为啥会有差异？简单图例一下
3. 建好堆之后的调整阶段，从最大值到最小值依次归位，时间复杂度O（n*log n）

时间复杂度O（n*log n），不管以什么方式建堆，调整阶段的时间复杂度都是这个，所以整体复杂度也是这个。额外的空间复杂度为O(1)，因为没有分配新的空间，完全在原来的数组上调整的



注意：堆结构比堆排序有用的多，尤其是和比较器结合之后，后面几节课会重点讲述



### 标准库中的应用

java中的优先队列PriorityQueue, python中的heapq，cpp中的priority_queue都是采用的堆结构，实现的。

