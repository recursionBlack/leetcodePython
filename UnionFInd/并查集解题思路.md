# 并查集解题思路

并查集（DSU）的使用场景是如下的场景：

一开始每个元素都有自己的集合，在自己的集合里，只有这个元素自己

find(i)：查找i所在集合的代表元素，代表元素代表i所在的集合

boolean isSameSet(a, b) ： 判断a和b在不在一个集合里

void union(a, b): 将a所在集合的元素，与b所在集合的元素，合并为一个集合

并查集的各种操作，单次调用的均摊时间复杂度为O(1)

### 并查集的两个优化

都发生在find方法里

扁平化，一定要做,。

所谓扁平化，就是，查找的时候，直接去掉中间商赚差价，让每个元素的上级直接指向集合的代表元素,也叫路径压缩。

小挂大，可以不做。原论文中，是秩的概念，可以理解为 粗略高度，或者大小



### 通用解题技巧

并查集题解，往往需要定义一个类，然后定义出father容器和size容器，以及sets属性。father容器，表示每个集合的代表元素，size表示每个集合的容量，sets表示剩余的集合数量。size容器其实不是必须的，目前做的三个题，都没有涉及到size容器的使用。

另外，还需要定义，两个接口，find和union接口，以及，为每个题意的元素，定义一个单独的集合。后续，再将这些集合，一个个合并起来，从而根据题意得出答案。

另外，注意，并查集算法的每个测例，都要单独定义一个对象，不像别的算法可以通用一个对象
