# 并查集解题思路

### 定义

并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的合并及查询问题，通常有两种操作，查找与合并

### 使用场景

并查集（DSU）的使用场景是如下的场景：

一开始每个元素都有自己的集合，在自己的集合里，只有这个元素自己

find(i)：查找i所在集合的代表元素，代表元素代表i所在的集合，单次操作复杂度为O(a(n))

boolean isSameSet(a, b) ： 判断a和b在不在一个集合里

void union(a, b): 将a所在集合的元素，与b所在集合的元素，合并为一个集合,单次操作复杂度为O(a(n))

并查集的各种操作，单次调用的均摊时间复杂度为O(1), 其中 *α* 为阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。

还有一种经典的使用场景，就是，a与b相连，b与c相连，所以，a，b，c被视为联通的，类似于这种问题，就可以使用并查集了。

### 并查集的两个优化

都发生在find方法里

扁平化，一定要做,。

所谓扁平化，就是，查找的时候，直接去掉中间商赚差价，让每个元素的上级直接指向集合的代表元素,也叫路径压缩。

小挂大，可以不做。原论文中，是秩的概念，可以理解为 粗略高度，或者大小

### 通用解题模板

并查集题解，往往需要定义一个类，然后定义出father容器和size容器，以及sets属性。father容器，表示每个集合的代表元素，size表示每个集合的容量，sets表示剩余的集合数量。size容器其实不是必须的，目前做的三个题，都没有涉及到size容器的使用。

另外，还需要定义，两个接口，find和union接口，以及，为每个题意的元素，定义一个单独的集合。后续，再将这些集合，一个个合并起来，从而根据题意得出答案。

另外，注意，并查集算法的每个测例，都要单独定义一个对象，不像别的算法可以通用一个对象

### 并查集在环中的应用

有些树，添加一条边，可以变成环，而使用并查集，可以找到，哪条边，将树变成了环。对于一个边中的两个节点，只要有一个不在并查集中，那么该节点就仍然只能构成树。如果两个节点都在并查集里，说明就是该边导致树变环了，需要删掉该边

### 交替染色法与并查集

二分图，通常用交替染色法来解，是最简单的，但，也能引入并查集。交叉染色法，是用一个颜色数组，来记录每个节点的颜色。而并查集，则用两个集合来存储两种节点。而且，事实上，用并查集强行代替染色法来解决，往往效率会很低。

